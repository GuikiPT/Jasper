import type { Subcommand } from '@sapphire/plugin-subcommands';
import { MessageFlags } from 'discord.js';

import { VirusTotalChatInputInteraction } from './types';
import { getSecurityStatus, getMaliciousEngines, createReportComponents, handleVirusTotalError, formatUnixDate } from './utils';

// Handle /virustotal ip subcommand: analyze IP address reputation
export async function chatInputVirusTotalIp(_command: Subcommand, interaction: VirusTotalChatInputInteraction) {
    const address = interaction.options.getString('address', true);
    const isEphemeral = interaction.options.getBoolean('ephemeral') ?? true;

    await interaction.deferReply({ flags: isEphemeral ? MessageFlags.Ephemeral : [] });

    try {
        // Fetch IP data from VirusTotal
        const data = await _command.container.virusTotalService.fetchIp(address);

        const stats = data.data.attributes.last_analysis_stats;
        const attributes = data.data.attributes;
        const status = getSecurityStatus(stats);

        // Extract IP metadata
        const metadata = extractIpMetadata(attributes);

        // Build detailed text report for download
        const detailedReport = buildDetailedReport(address, attributes, stats, metadata);

        // Build Discord component sections
        const sections = buildReportSections(address, stats, metadata);

        const components = createReportComponents(
            'VirusTotal IP Report',
            status,
            sections,
            `https://www.virustotal.com/gui/ip-address/${address}`,
            `virustotal-ip-${address}.txt`
        );

        await interaction.editReply({
            files: [
                {
                    attachment: Buffer.from(detailedReport),
                    name: `virustotal-ip-${address}.txt`
                }
            ],
            components,
            flags: MessageFlags.IsComponentsV2
        });
    } catch (error) {
        const errorMessage = handleVirusTotalError(error, { address });
        await interaction.editReply({ content: errorMessage });
    }
}

// Extract IP metadata from VirusTotal attributes
function extractIpMetadata(attributes: any) {
    const totalVotes = attributes.total_votes || {};
    const maliciousEngines = getMaliciousEngines(attributes.last_analysis_results || {});

    return {
        country: attributes.country || 'Unknown',
        asOwner: attributes.as_owner || 'Unknown',
        reputation: attributes.reputation || 0,
        harmlessVotes: totalVotes.harmless || 0,
        maliciousVotes: totalVotes.malicious || 0,
        tags: attributes.tags || [],
        lastAnalysisDate: formatUnixDate(attributes.last_analysis_date),
        maliciousEngines
    };
}

// Build comprehensive text report for download
function buildDetailedReport(address: string, attributes: any, stats: any, metadata: any): string {
    return `
VIRUSTOTAL IP ANALYSIS REPORT
=============================

IP ADDRESS: ${address}
COUNTRY: ${attributes.country || 'Unknown'}
CONTINENT: ${attributes.continent || 'Unknown'}
AS OWNER: ${attributes.as_owner || 'Unknown'}
ASN: ${attributes.asn || 'Unknown'}
NETWORK: ${attributes.network || 'Unknown'}
REGIONAL INTERNET REGISTRY: ${attributes.regional_internet_registry || 'Unknown'}

REPUTATION SCORE: ${attributes.reputation || 0}/100

LAST ANALYSIS DATE: ${metadata.lastAnalysisDate}

DETECTION SUMMARY:
- MALICIOUS: ${stats.malicious || 0} engines
- SUSPICIOUS: ${stats.suspicious || 0} engines
- CLEAN: ${stats.harmless || 0} engines
- UNDETECTED: ${stats.undetected || 0} engines

COMMUNITY VOTES:
- HARMLESS: ${metadata.harmlessVotes}
- MALICIOUS: ${metadata.maliciousVotes}

TAGS: ${metadata.tags.length > 0 ? metadata.tags.join(', ') : 'None'}

MALICIOUS DETECTIONS:
${metadata.maliciousEngines.length > 0 ? metadata.maliciousEngines.map((engine: string) => `- ${engine}`).join('\n') : 'None detected'}

WHOIS INFORMATION:
${attributes.whois || 'Not available'}

LAST ANALYSIS RESULTS (Detailed):
${Object.entries(attributes.last_analysis_results || {})
            .map(([engine, result]: [string, any]) => `${engine}: ${result.category} (${result.result || 'N/A'})`)
            .join('\n')}

CERTIFICATE INFORMATION:
${attributes.last_https_certificate
            ? `
ISSUER: ${attributes.last_https_certificate.issuer?.CN || 'Unknown'}
SUBJECT: ${attributes.last_https_certificate.subject?.CN || 'Unknown'}
VALID FROM: ${attributes.last_https_certificate.validity?.not_before || 'Unknown'}
VALID TO: ${attributes.last_https_certificate.validity?.not_after || 'Unknown'}
THUMBPRINT: ${attributes.last_https_certificate.thumbprint || 'Unknown'}
`
            : 'No certificate information available'
        }

JARM FINGERPRINT: ${attributes.jarm || 'Not available'}

TOTAL VOTES: ${JSON.stringify(attributes.total_votes || {}, null, 2)}

Generated by Jasper Bot - ${new Date().toISOString()}
Powered by VirusTotal API
    `.trim();
}

// Build Discord component sections for display
function buildReportSections(address: string, stats: any, metadata: any): Array<{ title: string; content: string }> {
    return [
        {
            title: 'üìç **General Information**',
            content:
                `‚Ä¢ **IP Address:** \`${address}\`\n` +
                `‚Ä¢ **Country:** \`${metadata.country}\`\n` +
                `‚Ä¢ **Owner:** \`${metadata.asOwner}\`\n` +
                `‚Ä¢ **Reputation:** \`${metadata.reputation}/100\``
        },
        {
            title: 'üìà **Detection Summary:**',
            content:
                `‚Ä¢ **Malicious:** \`${stats.malicious || 0}\` engines\n` +
                `‚Ä¢ **Suspicious:** \`${stats.suspicious || 0}\` engines\n` +
                `‚Ä¢ **Clean:** \`${stats.harmless || 0}\` engines\n` +
                `‚Ä¢ **Undetected:** \`${stats.undetected || 0}\` engines`
        },
        {
            title: 'üó≥Ô∏è **Community & Analysis**',
            content:
                `**Community Votes:**\n` +
                `\`${metadata.harmlessVotes}\` ‚úÖ | \`${metadata.maliciousVotes}\` ‚ùå\n\n` +
                `**Last Analyzed:**\n` +
                `\`${metadata.lastAnalysisDate}\`` +
                (metadata.tags.length > 0 ? `\n**Tags:** \`${metadata.tags.join(', ')}\`` : '') +
                (metadata.maliciousEngines.length > 0 ? `\n‚ö†Ô∏è **Detected by:** \`${metadata.maliciousEngines.join(', ')}\`` : '')
        }
    ];
}
